    当我们通过C程序，调用C标准库函数操作文件或者设备时，这些标准库函数实际上会通过系统调用把读写请求传达给内核，
最终由内核驱动文件磁盘或者设备，从而完成IO操作，例如:
    - fopen函数要通过 open(2) 系统调用来打开一个文件;
    - fclose() 函数要通过 close(2) 系统调用来关闭文件;
    - fgetc/fgets/fread/fscanf 等函数要通过 read(2) 系统调用来请求内核读设备;
    - fputc/fputs/fwrite/fprintf 等函数要通过 write(2) 系统调用来请求内核写设备;
    等等...



    C语言通过fopen()打开一个文件，会分配一个用户空间(用户态)IO缓冲区，以便加快读写操作的速度。可以通过对应的文件句柄(FILE*)中的成员访问到这个
缓冲区，通常来说，调用的读写操作函数大多数都是在这个用户态的IO缓冲区中读写，只有在少数时候才会把读写请求传给内核。以读写为例:

    读流程: 当用户第一次调用fgetc()读取一个字节时，fgetc函数可能通过read(2)系统调用进入内核读取1k字节到缓冲区，然后返回缓冲区中的第一个字节给用户，
再将读写位置指向第二个字节，以后再次读取时，将会直接从缓冲区中第二个字节开始读取，而不需要进入内核，直到缓冲区中的1k字节全部读取完后，再次调用
fgetc函数，就会再次进入内核读取1k字节到缓冲区。

    写流程: 当用户调用fputc写入一个字节时，也是优先写入到缓冲区，这样写入的效率会非常高。当IO缓冲区写满时，就会通过write(2)系统调用将IO缓冲区
中的数据传给内核，由内核将数据写入到磁盘中。如果某个时刻用户程序希望把IO缓冲区中的数据立刻写到内核中，而不是等IO缓冲区满了后再写到内核，
这称为Flush操作，可以调用fflush()函数完成此操作。fclose()函数会在文件关闭之前也执行Flash操作。

补充(1): 当调用fflush(NULL)时，可以对当前进程打开的所有文件进行Flash操作。

补充(2): ffIush只保证通过write(2)系统调用将数据写回内核，并不保证数据一定写到了设备上，
通常内核里也会有一个I/O缓存，如果一定要求内核把数据写到设备上可以调用fsync(2)。


    C标准库的IO缓冲区有三种类型： 全缓冲、行缓冲和无缓冲。当用户程序调用函数进行写操作时，不同的类型缓冲区具有不同的特性。

    - 全缓冲: 如果缓冲区写满了就写回内核。常规文件通常是全缓冲的。

    - 行缓冲: 如果用户程序写的数据中有换行符就把这一行写回内核,同样的如果缓冲区写满了一会写回内核。标准输入与标准输出对应的终端设备通常是行缓冲。
        除了写满缓冲区和遇到换行符之外，行缓冲还有两种情况会导致被flush:
            1. 用户程序调用库函数从某个无缓冲的文件中读取；
            2. 用户程序调用库函数从某个行缓冲的文件中读取，并且这次读操作会引发read(2)系统调用从内核读取数据。
        例如:
            printf("hello world");
            fgets(buf,20,stdin);
        虽然调用printf并不会写回内核，但紧接着调用fgets读一个行缓冲的文件（标准输入），在读取之前会自动Flush所有行缓冲，包括标准输出，所以字符串会打印出来。

    - 无缓冲: 用户程序每次调用库函数做写操作都要立刻写回内核。
             标准错误输出通常是无缓冲的，这样用户程序产生的错误信息可以尽快输出到设备。



