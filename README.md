# C学习笔记

# 进制
## 什么是进制?
>进制就是一种表示数值的方法，它能够通过最基本的数字和字符来表示更多更大的数值;

常见的进制有十进制、二进制、八进制和十六进制。

## 十进制

十进制是生活中最常用的进制，它使用[0~9]的数字表示所有的数值，如果数值超过了9，则进1表示为`10`。

那为什么选用该进制作为人类生活中的进制呢？其实很简单，因为人都有十根手指，这样便于我们进行十进制的计算;
<hr>
## 二进制

二进制是计算机所使用的进制，它使用[0~1]的数字表示所有的数值，因为计算机底层存储的一切数据都是用0和1来表示，无论是数字、字符、图片、视频等资源，最终都必须转换为二进制数据才可以被计算机所识别或存储;

二进制只有0和1两个数字表示，满2进1。

比如十进制中的1、2、3、4、5，在二进制中表示为 0、1、10、11、100;
<hr>
## 十六进制

十六进制也是计算机中常用的一种进制，它使用[0~9] + [A-F]来表示所有的数值;



进制之间的映射关系:

| 十进制 | 二进制 | 八进制 | 十六进制 |
| ------ | ------ | ------ | -------- |
| 0      | 0      | 0      | 0        |
| 1      | 1      | 1      | 1        |
| 2      | 10     | 2      | 2        |
| 3      | 11     | 3      | 3        |
| 4      | 100    | 4      | 4        |
| 5      | 101    | 5      | 5        |
| 6      | 110    | 6      | 6        |
| 7      | 111    | 7      | 7        |
| 8      | 1000   | 10     | 8        |
| 9      | 1001   | 11     | 9        |
| 10     | 1010   | 12     | A        |
| 11     | 1011   | 13     | B        |
| 12     | 1100   | 14     | C        |
| 13     | 1101   | 15     | D        |
| 14     | 1110   | 16     | E        |
| 15     | 1111   | 17     | F        |
| ...    |        |        |          |

<hr>



## 进制之间的转换

### 进制的基与权

基(Base): 基数，表示用多少不同的符号来表示数字，也就是进制的进制数，如二进制基数为2，十进制进制为10;

位: 表示多位数以从右往左的顺序，每一位数所在的位置;

权: 指的是每一位数字所占的位置对数字的贡献，所有的权累加在一起就是该数的总大小。权的计算公式: `当前位值 * (基数 ^ 位)`;



通过进制的基与权，可以更方便完成进制之间的转换;

<hr>

### 二进制转十进制
如图所示:

[//]: # "<img src="./imgs/二进制转十进制.png" style="zoom: 50%">"

- 该数为二进制，所以基数为2;
- 从右往左表示，位数从0开始，首位为0位，第二位为1位...以此类推;
- 每一位的权： 值 * (基数 ^ 位)
- 计算得出每位的权后，全部相加变得出总值;
<hr>

### 其他进制转十进制
```java
/**
 * 进制之间的转换。通过进制的基数、位、权进行转换
 *
 * 二进制转十进制:
 *  1101 --> 十进制  基数为2
 * 值:      1          1          0         1
 * 位:      3          2          1         0
 * 权:   1*(2^3)    1*(2^2)   1*(2^1)   1*(2^0)      权: 值 * (基^位)
 *      8           4         0         1
 * 1101 --> 13
 *
 *
 *
 * 八进制转十进制:
 *  123 --> 八进制  基数为8
 * 值:  1            2             3
 * 位:  2            1             0
 * 权: 1*(8^2)    2*(8^1)      3*(8^0)     权 = 值 * (基数 ^ 位)
 *     64           16            3
 * 123 --> 83
 *
 *
 * 十六进制转十进制
 * 48B38 --> 十进制 基数为16
 * 值:   4           8           B           3           8
 * 位:   4           3           2           1           0
 * 权:  4*(16^4)   8*(16^3)   11*(16^2)    3*(16^1)    8*(16^0)
 *      262144      32768       2816        48          8
 * 48B38 --> 297784
 *
 */
```

### 十进制转其他进制

```java
/**
 *
 *
 * 十进制转二进制
 * 205 --> 二进制   基数为2
 * 用数值 / 基数 得出商和余数，再使用商 / 基数，直到被除数小于除数后，将所有的余数倒序排列起来,得出的结果就是对应的二进制;
 *
 * 205  /   2  =  102   余   1
 * 102  /   2  =   51   余   0
 * 51   /   2  =   25   余   1
 * 25   /   2  =   12   余   1
 * 12   /   2  =    6   余   0
 * 6    /   2  =    3   余   0
 * 3    /   2  =    1   余   1
 * 1    /   2  =    0   余   1
 *
 * 205 --> 11001101
 *
 * 十进制转八进制
 * 83 --> 八进制   基数为8
 * 83   /   8   = 10  余  3
 * 10   /   8   = 1   余  2
 * 1    /   8   = 0   余  1
 *
 * 83(十进制) --> 123(八进制)
 *
 */
```

<hr>

# 原码、反码和补码

在计算机中，数据都由0和1所组成，而一个0或1所占单位是一个位(bit)，这是计算机中最小的计量单位。

我们通常在编程中会使用字节(byte)作为最小单位，1byte = 8bit，也就是`0000 0000`;

比如我们常用的`uint8`无符号整型，它就是占1byte(8bit)的空间，所以它的长度范围就是`0000 0000` ~ `1111 1111`，也就是0~255;

## 什么是原码、反码和补码?

> 原码、反码和补码是计算机中用于表示带符号整数的三种不同的表示方法。它们主要用于解决计算机中整数运算中的溢出问题。




## 原码

上面我们说了，实际上所有的数字都是使用0和1这种二进制数据表示，但是这样只能表示正数，那负数怎么办？
原码是一种解决表示正负数的解决方案之一: 原码使用首位表示正负数标识符号，0为正数，1为负数，其余位表示值。

`1000 0001`表示为-1。首位为1，标识此数为负数，其余位表示值`000 0001`,也就是数字1;

`0000 0001`表示为1，首位为0，表示正常正数;

由于我们使用首位bit作为标识位，那么值的长度范围就会受到影响，不再是0~255，因为`0111 1111`最大表示为127;

长度范围为: `1 111 1111`~`0 111 1111`，即:[-127 ~ 127];
这也是很多语言中`int8`有符号整型的长度范围;

虽然原码表示正负数很简单，但是原码在做运算的时候很麻烦，于是引入了反码;

<hr>

## 反码
反码是在原码的基础之上，首位标识位不变，其余位全部取反;

- 正数的反码就是它本身;
- 负数的反码首位标识位不变，其余位全部取反;

如下，1与-1在原码和反码中的表示区别:

|      | 原码      | 反码      |
| ---- | --------- | --------- |
| 1    | 0000 0001 | 0000 0001 |
| -1   | 1000 0001 | 1111 1110 |

此时有了反码之后，我们就可以进行正数与负数之间的运算。以 `1 + (-1) = 0`为例:
1. 将1和-1进行反码后进行相加运算，即: `0000 0001` + ` 1111 1110` = `1111 1111`;
2. 然后再对得出的`1111 1111`进行反码,得到`1000 0000`;
3. `1000 0000`原码中表示为-0，最终通过反码的方式得出 `1 + (-1) = -0`;



反码的范围与原码一致,即[-127 ~ 127];

我们思考一下，0有正负之分吗，`0000 0000`表示为0，而`1000 0000`又表示为-0，这似乎依然不太合理，由此又引出了补码!

<hr>

## 补码
补码是指在原码的基础之上，首位标识位不变，其余位全部取反后，最后再+1(也可以理解为直接在反码基础之上+1);
- 正数的补码依然还是其本身;
- 正数的反码，首位标识符不变，其余位全部取反之后，再+1;

如下,1与-1在原码、反码和补码中的表示:

|      | 原码      | 反码      | 补码      |
| ---- | --------- | --------- | --------- |
| 1    | 0000 0001 | 0000 0001 | 0000 0001 |
| -1   | 1000 0001 | 1111 1110 | 1111 1111 |

接下来我们再通过补码进行`1 + (-1) = 0`的运算过程:

1. 使用1和-1的补码进行相加,即: `0000 0001` + `1111 1111` = `0001 0000 0000`;
2. 得出的结果为`1 0000 0000`,相加之后直接进位了，已经溢出了8个bit位，所以会直接抹除掉，最终结果为:`0000 0000`，也就是0;



与原码与反码不同的是，补码的8位二进制范围为[-128 ~ 127],诶 为什么呢？

问题就出现在补码的+0与-0身上!

+0 与 -0 在原码、反码和补码中的表示:

|      | 原码      | 反码      | 补码      |
| ---- | --------- | --------- | --------- |
| +0   | 0000 0000 | 0000 0000 | 0000 0000 |
| -0   | 1000 0000 | 1111 1111 | 0000 0000 |

你会发现在补码中,0 表示为`0000 0000`，而-0也表示为`0000 0000`，即0的表示只有一种;

我们再来分析一下 -0 的补码怎么来的:
1. 首先 -0 在原码中表示为`1000 0000`;
2. 然后反码在原码的基础之上，除了标识位，其他全部取反，得出`1111 1111`;
3. 最后补码又再反码的基础之上 +1，直接进位抹除掉，得出`0000 0000`;

所以在补码可以多表示一个值为-128的数,即范围[-128 ~ 127]，-128补码使用`1000 0000`表示;

最终通过补码解决正负数之间的运算溢出问题，C、Go语言中就是使用的补码!

<hr>

## 补码运算示例

接下来我们通过两个示例来进一步讲解补码运算的流程。

**有符号整数的补码运算:**

```go
var a int8 = 1
var b int8 = 2
fmt.Println(a - b) // -1
```

1. `1` - `2` 在计算机中表示为`1 `+` -2`，所以先获取对应的补码;
2. `1`为正数，它的补码就是本身的二进制数，即`0000 0001`;
3. `-2`为负数，它的原码为`1000 0010`，反码为`1111 1101`，其补码为`1111 1110`;
4. 有了两个数的补码，就可以进行相加运算: `0000 0001` + `1111 1110` = `1111 1111`;
5. 得到一个原码值`1111 1111`，但是由于是有符号整数，所以要取得值的补码;
6. 结果值的反码为 `1000 0000`,补码为`1000 0001`，转换为十进制也就是`-1`;



**无符号整数的补码运算:**

```go
var a uint8 = 1
var b uint8 = 2
fmt.Println(a - b) // 255
```

1. `1` - `2` 在计算机中表示为`1 `+` -2`，所以先获取对应的补码;
2. `1`为正数，它的补码就是本身的二进制数，即`0000 0001`;
3. `-2`为负数，它的原码为`1000 0010`，反码为`1111 1101`，其补码为`1111 1110`;
4. 有了两个数的补码，就可以进行相加运算: `0000 0001` + `1111 1110` = `1111 1111`;
5. 得到一个原码值`1111 1111`，但是由于是无符号整数，所以直接该原码值就是结果,转换为十进制也就是`255`;



<hr>






# 编码

## 什么是编码?

> 编码是指将一种形式的数据转换成另一种数据的过程,并且保证数据的准确与完整性

在上面我们提到了计算机中存储的一切数据都是二进制数据0和1，那么如果想存储一段字符或文字就要想办法将其转换为二进制才可以被存储;

## ASCll编码

ASCll是一种字符编码标准，用于将字符(字母、数字、标点符号等)与数字之间建立对应关系，ASCII编码将每个字符映射到一个唯一的整数值。
如字符`A` 在ASCll码表中表示如下:

|  | 二进制   | 十进制 | 十六进制 |
| -- | -------- | ------ | -------- |
| A  | 01000001 | 65     | 41       |

[更多映射可参考这里](http://c.biancheng.net/c/ascii/)

但是ASCll是单字节编码，无法用于对中文汉字进行编码映射，因为中文编码至少需要2个字节，所以，中国制定了GB2312编码，用来把中文编进去。

但世界上有许多不同的语言，需要一种统一的编码，所以Unicode编码由此而生;
<hr>

## Unicode编码

Unicode是一种统一编码标准，为世界上所有的字符和符号提供一个唯一的数字标(十六进制)，把所有语言都统一到一套编码里，这样就不会再有乱码问题了;

Unicode最常用的是用两个字节表示一个字符(如果要用到非常偏僻的字符，就需要4个字节);

如字符`A`在Unicode码表中表示的十六进制为`\u0041`

如汉字`我`在Unicode码表中表示的十六进制为`\u6211`

[更多映射可参考这里](https://www.ifreesite.com/unicode/character.htm)

<hr>

## Unicode和ASCII的区别

ASCll编码是1个字节单位，而Unicode编码通常是2个字节单位;

字母A用ASCII编码是十进制的65，二进制的01000001；而在Unicode中，只需要在前面补0，即为：00000000 01000001。



虽然解决了乱码问题，但是由此引出了新的问题: 如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。
从而诞生了UTF-8编码。

<hr>

## UTF8

UTF8是Unicode标准的一种编码实现方式。UTF-8是一种变长编码，意味着不同的字符可以使用不同数量的字节进行编码。

UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。

| 字符   | ASCll     | Unicode             | UTF-8               |
| ------ | --------- | ------------------- | ------------------- |
| 'A'    | 0100 0001 | 0000 0000 0100 0001 | 0100 0001           |
| '中文' |           | 0100 1110 0010 1101 | 0100 1110 0010 1101 |

如上所示: 使用UTF-8编码，单字符编码体积会明显节省空间，与ASCll一致，而汉字编码则与Unicode一致，简单来说UTF-8就是Unicode与ASCll两者的结合;

<hr>



# 编译第一个C程序

学习C语言，先简单来问候一下，创建`main.c`文件

```c
#inclued <stdio.h>

int main(){
  printf("hello world")
  return 0;
}
```

然后编译:

```sh
gcc -std=gnu99 -Wall main.c -o main
```

编译后得到一个名为`main`的可执行程序，直接运行:

```sh
./main
hello world
```



<hr>



# 基本数据类型

## 整数类型
整数，也就是不包含小数点的数值，包含如下几种类型:

| 类型    | 符号 | 所占字节  | 范围                             |
|-------|-----|-------|--------------------------------|
| short | 有 | 2 | -32768 ~ 32767                 |
| int   | 有 | 4 | -2,147,483,648 ~ 2,147,483,647 |
| long  | 有 | 4 | -2,147,483,648 ~ 2,147,483,647 |
|long long|有|8|-9223372036854775808 ~ 9223372036854775807|
|unsigned short|无|2|0~65535|
|unsigned int|无|4|0~4294967295|
|unsigned long|无|4|0~4294967295|
|unsigned long long|无|8||
需要注意的是: `long`类型在32位操作系统中与`int`一样为4字节，64位系统中为8字节;

## 浮点型

| 类型   | 符号 | 所占字节 |
| ------ | ---- | -------- |
| float  | 有   | 4        |
| double | 有   | 8        |

## 字符型
除了保存数字以外，C语言还支持字符类型，每一个字符都可以使用字符类型来保存

| 类型   | 描述  | 所占字节  |
|------|-----|-------|
| char | 字符型 | 1byte |

字符型占用1个byte(-128 ~ 127)，表示的ASCll码表中任意一个字符的十进制值，每个数字对应ASCll中的一个字符;



<img src="./imgs/ASCll码表.png">

<hr>

变量声明方式，以及字节占用情况:

```c
#include <stdio.h>
int main(){
  // 声明一个short类型的变量，初始值为0
  short n1;
  printf("short 类型所占字节数: %lu \n", sizeof(n1));
  // 声明一个int类型变量
  int n2 = 9999;
  printf("int 类型所占字节数: %lu \n", sizeof(n2));
  // 声明一个long类型变量
  long n3 = 10001;
  printf("long 类型所占字节数: %lu \n", sizeof(n3));
  // 声明一个char 类型变量
  char n4 = 'A';
  printf("char 类型所占字节数: %lu \n", sizeof(n4));
  float n5;
  printf("float 类型所占字节数: %lu \n", sizeof(n5));
  double n6;
  printf("double 类型所占字节数: %lu \n", sizeof(n6));
  return 0;
}

```

执行结果:

```sh
short 类型所占字节数: 2 
int 类型所占字节数: 4 
long 类型所占字节数: 8 
char 类型所占字节数: 1 
float 类型所占字节数: 4 
double 类型所占字节数: 8 
```



<hr>



# 复杂类型

## 数组

> 数组是一种很常见的数据类型，其实从本质上来讲并没有什么数组，所谓数组就是: 一个起始地址(指针) + 后续要占用的连续内存;

注意: C语言的数组不像Java和Python那样在堆中分配，如果不使用`malloc`，则都会在栈中分配;

定义数组如下:

```c
// 定义一个int类型的数组，长度为4
int numbers [4];

// 定义一个int类型数组，长度为4，并且初始化元素为1,2,3
int numbers2 [4] = {1,2,3};

// 定义一个数组，长度为初始化元素的数量
int numbers3 [] = {1,2,3,4,5,6};
```

### 数组的本质是什么?

```c
int arr[] = {1,2,3,4};
```

这里的`arr`变量是什么? 其实这里的`arr`是一个指针，它指向了该数组中的起始地址，也就是首个元素的地址，如下所示:

```c
int arr[] = {1,2,3,4};
printf("%p,%p \n",arr,&arr[0]); // 0x16d273170,0x16d273170 
printf("%p,%p \n",arr,&arr[1]); // 0x16d273170,0x16d273174
printf("%p,%p \n",arr,&arr[2]); // 0x16d273170,0x16d273178
```

从结果上就可以看出,`arr`的指针就是指向的`arr[0]`数组的第一个元素的地址，并且每个元素的地址相差4个byte，因为int类型占4个byte;

### 指针运算

> 指针运算就是将指针进行左右移动，通过索引来访问数组本质上就是通过指针移动来实现的

```c
#include <stdio.h>
int main(){
  int arr[] = {1,2,3,4};
  // 获取数组的指针
  int* ptr = arr;

  // 获取第一个元素的值
  int v1 = *ptr;

  // 将指针移动到第二个元素
  // 由于是int类型，所以会往后移动4个byte
  ptr++;
  // 获取第二个元素的值
  int v2 = *ptr;

  // 获取第三个元素的值
  int v3 = *(++ptr);

  // 获取第四个元素的值
  int v4 = *(++ptr);

  printf("%d \n",v1); // 1
  printf("%d \n",v2); // 2
  printf("%d \n",v3); // 3
  printf("%d \n",v4); // 4
  return 0;
}
```

指针移动的单位取决于指针的类型，如`int`就是一次移动4byte;

假如我们想获取索引为2的元素，有如下几种方式:

```c
int arr[] = {1,2,3,4};
printf("%d \n",arr[2]);			// 3
printf("%d \n",*(arr + 2)); // 3
printf("%d \n",2[arr]);			// 3
```

**索引访问本质上就是指针的移动!**

### 指针越界

C语言中的指针是非常灵活的，如果指针移动到了数组之外，并不会产生越界，不过若是访问超过了该进程内的内存范围，操作系统则会杀掉该进程;





<hr>



## 字符串

在C语言中，使用`char`作为字符类型，它占用1byte(8bit)位，其本质上对应的是一个字符的ASCll码值。

```c
#include <stdio.h>

int main(){
    char c = 'A';
    printf("c变量的值: %c, 字节大小: %lu, ASCll码值(16进制): %x \n",c, sizeof(c), c);

    // 通过十六进制，定义字符
    char c2 = 0x41;
    printf("c2: %c \n", c2);
    return 0;
}
```

```sh
c变量的值: A, 字节大小: 1, ASCll码值(16进制): 41 
c2: A 
```

在C语言中，并没有提供字符串类型，需要通过数组+`char`来组成一个字符串，如何定义字符串如下:

```c
char name[] = "ABC";
printf("%s",name); // name: ABC, length: 4
```

当我们没有指定数组的长度时，编译器会自动推导长度，`ABC`的长度为3，而C语言中会为每个字符串追加一个字符`\0`，表示为结束符，所以长度为4;

## 指针类型

指针类型用于存储一个十六进制的数值，而这个值通常指向内存中的一个地址;

```c
#include <stdio.h>

int main(){
    // 定义变量
    short num = 257;
    // 获取num的指针
    short* address = &num;
    // 通过指针获取值
    short val = *address;

    printf("num的值: %d \n",num);
    printf("num的指针: %p \n", address);
    printf("%p地址中的值: %d \n",address, val);
  
  	// 通过指针来修改值
  	*address = 255;
    printf("num的值: %d \n",num);
    return 0;
}
```

```sh
num的值: 257 
num的指针: 0x16b8f31ca 
0x16b8f31ca地址中的值: 257 
num的值: 255
```

通过`&`操作符，可以获取一个变量的指针;

指针类型分别不同类型的指针类型，在类型后添加`*`符号，则表示为指针类型，如: `int*`、`char*`、`long*`;

变量的指针，会指向该变量的内存起始地址，通过`*`符号会寻址到变量的起始地址，然后依照指针的类型元素，读取对应的字节长度: 如`int*`类型，则会从起始位置读取4个字节，并且以补码的方式来解释;

`void*` 是一个特殊的指针类型，它可以接收任意类型的指针:

```c
char c = 'a';
char name[] = "abc";

void* any_address = &c;
void* any_address2 = name;
printf("%p\n",any_address); // 0x16f2df1bd
printf("%p\n",any_address2); // 0x16f2df1b8
```

注意: `void*`只能用于存储指针，而不能用于读取或修改指针的值，因为它不知道究竟是什么类型.



<hr>

# 位运算

> 位运算是一种对二进制位（0 和 1）执行操作的计算技术。在计算机科学中，数据存储在计算机内存中的最小单位是位（bit），而字节（byte）则由多个位组成。位运算允许您直接操作数据的二进制表示，这在处理底层数据和优化代码时非常有用。

- 与运算(AND): 两个数位都为真(1)时则得出真(1)，有一个为假(0)则得出假(0);
- 或运算(OR): 两个数位都为假(0)时则得出假(0)，有一个为真(1)则得出真(1);
- 取反(NOT): 将所有的数位进行取反，真(1)转为假(0)，假(0)转为真(1);
- 异或(XOR): 两个数位只有一个为真(1)时则得出真(1)，如果都是真(1)或者都是假(0)则得出假(0);

## 与运算

`&` 与运算(AND): 当两个操作数位全为1则为1，否则为0。

示例如下:

```c
// 83 & 29 = 17

0101 0011 //(83)
0001 1101 //(29)
—————————
0001 0001 //(17)
```

## 或运算

`|` 或运算(OR): 两个操作数位全为0则为0，否则为1。可以理解为只要有一个数位为1，则为1;

示例如下:

```c
// 83 | 29 = 95

0101 0011
0001 1101 
—————————
0101 1111
```

## 取反

`~`取反运算(NOT): 将操作数的每个位进行取反，如果是0则为1，如果为1则为0。示例如下:

```c
// ~83 = 172(uint)
0101 0011
—————————
1010 1100
```

## 异或运算

`^`异或运算(XOR): 两个操作数位只有一个为1时才为1，否则为0;

或者你可以理解为 操作数位相同为0，不同则为1;

。示例如下:

```c
// 83 ^ 29 = 78

0101 0011 //(83)
0001 1101 //(29)
—————————
0100 1110 //(78)
```

## Bit Set

通过以上这些运算，我们可以实现Bit Set结构: 使用bit位表示不同的状态，在许多源码中都大量使用这些运算，优势如下:

- 高效的增删改查效率(CPU层级的o(1));
- 高效的内存使用率，最大可以使用1个byte(8bit)来表示8中状态;

接下来通过一个案例来进一步使用这些运算:

```c
//
// Created by Zero on 2023/8/24.
// 演示使用位运算实现 bit set结构
//
// Context: 学生一学期最多可以选8门课程，可以使用1个char类型表示选了哪些课程
// 0000 0000 每个bit位分别表示是否选了对应的课程

#include <stdio.h>


// 常量定义 每个常量表示一门对应的课程被选中的数位
//                        二进制     十进制
#define JAVA  0x1      //0000 0001 (1)     表示Java课程
#define GO  0x2        //0000 0010 (2)     表示Go课程
#define PYTHON  0x4    //0000 0100 (4)     表示Python课程
#define C  0x8         //0000 1000 (8)     表示C课程
#define CPP  0x10      //0001 0000 (16)    表示C++课程
#define RUST  0x20     //0010 0000 (32)    表示Rust课程
#define R  0x40        //0100 0000 (64)    表示R课程
#define JS  0x80       //1000 0000 (128)   表示Js课程


int main(void) {
  // 一共有8门课程，所以至少需要8个bit位来表示，C语言中char恰好就是8bit,所以使用char即可表示

  // 1.创建一个char变量，表示一个学生共选了哪些课程
  // 初始化未选任何课程: 0000 0000
  unsigned char course = 0;

  // 2.如何添加一门课程，例如添加Java这门课
  //  这种情况我们可以通过或运算(OR): 只要有一个数位为1，则为1;
  //    0000 0000 (0) 当前已选课程状态
  //    0000 0001 (1) 要添加的Java课程
  //    0000 0001 (1) 添加后的结果
  // 通过或运算，即便是我们一家选过这门课程，也依然不会有影响
  course = course | JAVA;


  // 2.1添加Go课程
  // 0000 0001 (1) 当前已选课程状态
  // 0000 0010 (2) 要添加的Go课程
  // 0000 0011 (3) 添加后的结果
  course |=  GO;

  // 2.2添加Rust课程
  // 0000 0011 (3)  当前已选课程状态
  // 0010 0000 (32) 要添加的Rust课程
  // 0010 0011 (35) 添加后的结果
  // 此时已经选了3门课程，值为35;
  course |= RUST;

  // 3. 如何判断学生是否选了一门课程？
  // 通过与运算(AND): 两个数位都为1则为1，否则为0;
  // 例如判断是否选了Go这门课程
  // course&GO 得出的结果为0，表示没有选这门课，如果不为0则表示选了这门课程;
  //
  // 0010 0011 (35) 当前已选课程状态
  // 0000 0010 (2)  Go课程
  // 0000 0010 (2)  运算后的结果，显然结果不为0，表示当前选了Go的课程
  if ((course & GO) != 0){
    printf("学生选了Go这门课程! \n");
  }


  // 3.1 判断是否选了R这门课程
  // 0010 0011 (35) 当前已选课程状态
  // 0100 0000 (64) R课程
  // 0000 0000 (0) 表示没有选R课程
  if((course & R) == 0){
    printf("学生没有选R这门课程!\n");
  }


  // 4. 如何取消一门课程? 例如取消Go这门课程
  // 有两种方案: 1. 通过与运算 + 取反运算; 2. 通过异或运算
  // 通过与运算 + 取反运算
  // course & (~GO)
  //
  // 对Go课程进行取反

  // 0000 0010 Go的课程
  // 1111 1101 取反后的Go课程
  //
  // 使用当前课程 & 取反后的Go课程
  // 0010 0011  当前已选课程状态
  // 1111 1101  取反后的Go课程
  // 0010 0001  进行与运算后的结果
  course &= (~GO);

  // 4.1通过异或运算取消Rust课程
  // 异或运算: 操作数位相同为0，不同则为1;
  // 0010 0001  当前已选课程状态
  // 0010 0000  Rust课程
  // 0000 0001  异或运算后的结果
  course ^= RUST;

  // 再次判断目前是否选了Go和Rust课程
  if((course & GO) == 0){
    printf("学生没有选择Go这门课程! \n");
  }
  if((course & RUST) == 0){
    printf("学生没有选择Rust这门课程! \n");
  }

  // 当前已选课程状态: 0000 0001,只选择了Java这门课程
  if((course & JAVA) != 0){
    printf("学生选了Java这门课程! \n");
  }
  return 0;
}
```

总结:

- 设置一个bit位为1，使用或运算(OR);
- 查询一个bit是否为1，使用与运算(AND);
- 将一个bit从1置为0，使用异或运算(XOR);

## 小练习

```c
//
// Created by Zero on 2023/8/24.
// 背景知识:
//  1. 在终端输入实际上是通过stdin这个文件输入
//  2. 每个进程开启时，都会打开3ge文件(stdin-> 0, stdout -> 1, stderr -> 2)
//  3. 你能看到输入的字符是因为ECHO属性，我们的任务则就是它这个属性关闭，然后再开启
//
// 案例: 通过终端输入获取一个账号和密码，要求密码输入是不可见的
//

#include <stdio.h>
#include <termios.h> // 更改终端的属性

// 用于关闭 ECHO属性的函数
void shutdown_echo(void){
  // 获取终端属性参数
  struct termios origin;
  tcgetattr(0,&origin);

  // 取消ECHO属性
  origin.c_lflag &= ~ECHO;
  // 刷新终端属性
  tcsetattr(0,TCSAFLUSH,&origin);
}

// 用于开启ECHO属性的函数
void add_echo(void){
  struct termios origin;
  tcgetattr(0,&origin);
  // 添加ECHO属性
  origin.c_lflag |= ECHO;
  //刷新
  tcsetattr(0,TCSAFLUSH,&origin);
}


int main(void){
  char account_name[100];
  printf("请输入账号: ");
  // 阻塞读取终端输入，将输入写入到account_name数组中
  scanf("%s",account_name);

  char password[100];
  printf("请输入密码: ");
  // 隐藏终端输入
  shutdown_echo();
  // 阻塞读取终端输入
  scanf("%s",password);

  printf("您输入的账号为: %s，您输入的密码为: %s \n",account_name,password);
  // 显示终端输入
  add_echo();
  return 0;
}
```

<hr>

# 输入与输出

在`stdio.h`标准库中，提供了一些函数用于输入域输出:

- putchar(int): 用于将一个字符写入标准输出；
- getchar(): 它用于从标准输入（通常是键盘）获取一个字符;
- printf(): 用于将格式化的文本输出到标准输出;

