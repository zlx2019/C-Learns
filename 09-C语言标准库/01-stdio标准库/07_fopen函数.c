#include <stdio.h>
#include <stdlib.h>

/**
 * fopen函数用于打开一个本地文件;
 * 打开文件本质上来说，就是在操作系统中分配一些资源，用于保存该文件的状态信息，并且获取这些状态信息，称之为文件的标识，
 * 后续应用程序就可以通过这个文件标识对文件进行各种操作，关闭文件以及释放该文件的状态信息，使其文件标识失效，程序就无法再操作这个文件;
 *
 * FILE* fopen(const char*  path, const char* mode);
 * 打开成功则返回文件指针，出错则返回NULL，并且设置errno;
 *
 * 参数解释:
 *  - path: 要打开的文件路径,可以是相对路径也可以是绝对路径;
 *  - mode: 打开模式,该参数是一个字符串，由rwab+五个字符组合而成:
 *      r 表示只读;
 *      w 表示只写(覆盖模式);
 *      a 表示只写(追加模式);
 *      b 表示二进制模式，不写b则表示文本模式;
 *      rwa+四个字符有以下6种合法的组合：
 *          "r": 只读，文件必须已存在;
 *          "w": 只写，文件不存在则创建，如果文件已存在则把文件长度截断（Truncate）为0字节再重新写，也就是替换掉原来的文件内容;
 *          "a": 只写，文件不存在则创建，写入的数据会在文件内容末尾追加;
 *          "r+": 允许读写，文件必须已存在;
 *          "w+": 允许读写，文件不存在则创建，已存在则截断，覆盖原有所有内容;
 *          "a+": 允许读和追加写，文件不存在则创建;
 *
 *
 * FILE是C标准库中定义的结构体类型，其中包含该文件在内核中的标识[插图]、用户空间I/O缓冲区和当前读写位置等信息。
 * 像FILE ＊这样的指针称为不透明指针或句柄。
 */
int main(int argc, char *argv[]) {
    // 1. 以只读模式，打开文件
    FILE* file = fopen("~/.bash_history","r");
    // 关闭文件流
    fclose(file);

    // 2. 在打开一个文件时如果出错，fopen将返回NULL并设置errno。在程序中应该做出错处理，通常这样写：
    FILE* fp = fopen("a.txt","r");
    if(fp == NULL){
        fprintf(stderr,"error open file a.txt \n"); // error open file a.txt
        exit(1);
    }
    return 0;
}
